/** @file
  Configuration Manager Dxe

  Copyright (c) 2020 Puresoftware Ltd. All rights reserved.

  SPDX-License-Identifier: BSD-2-Clause-Patent

  @par Glossary:
    - Cm or CM   - Configuration Manager
    - Obj or OBJ - Object
**/

#include <IndustryStandard/DebugPort2Table.h>
#include <IndustryStandard/IoRemappingTable.h>
#include <IndustryStandard/MemoryMappedConfigurationSpaceAccessTable.h>
#include <IndustryStandard/SerialPortConsoleRedirectionTable.h>
#include <IndustryStandard/SmBios.h>
#include <Library/ArmLib.h>
#include <Library/DebugLib.h>
#include <Library/IoLib.h>
#include <Library/PcdLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/AcpiTable.h>
#include <Protocol/ConfigurationManagerProtocol.h>

#include <AcpiTables/Platform.h>
#include "ConfigurationManager.h"

// AML Code Include files generated by iASL Compiler
#include <Dsdt.hex>

#include "SmbiosTableHelper.h"
STATIC SMBIOS_STRUCTURE  SmbiosTable0Data  = {SMBIOS_TYPE_BIOS_INFORMATION, sizeof (SMBIOS_TABLE_TYPE0), SMBIOS_HANDLE_PI_RESERVED};
STATIC SMBIOS_STRUCTURE  SmbiosTable1Data  = {SMBIOS_TYPE_SYSTEM_INFORMATION, sizeof (SMBIOS_TABLE_TYPE1), SMBIOS_HANDLE_PI_RESERVED};
STATIC SMBIOS_STRUCTURE  SmbiosTable3Data  = {SMBIOS_TYPE_SYSTEM_ENCLOSURE, sizeof (SMBIOS_TABLE_TYPE3), SMBIOS_HANDLE_CHASSIS};
STATIC SMBIOS_STRUCTURE  SmbiosTable4Data  = {SMBIOS_TYPE_PROCESSOR_INFORMATION, sizeof (SMBIOS_TABLE_TYPE4), SMBIOS_HANDLE_A72_CLUSTER};
STATIC SMBIOS_STRUCTURE  SmbiosTable7Data  = {SMBIOS_TYPE_CACHE_INFORMATION, sizeof (SMBIOS_TABLE_TYPE7), SMBIOS_HANDLE_A57_L1I};
STATIC SMBIOS_STRUCTURE  SmbiosTable9Data  = {SMBIOS_TYPE_SYSTEM_SLOTS, sizeof (SMBIOS_TABLE_TYPE9), SMBIOS_HANDLE_PI_RESERVED};
STATIC SMBIOS_STRUCTURE  SmbiosTable16Data = {SMBIOS_TYPE_PHYSICAL_MEMORY_ARRAY, sizeof (SMBIOS_TABLE_TYPE16), SMBIOS_HANDLE_MEMORY};
STATIC SMBIOS_STRUCTURE  SmbiosTable17Data = {SMBIOS_TYPE_MEMORY_DEVICE, sizeof (SMBIOS_TABLE_TYPE17), SMBIOS_HANDLE_DIMM};
STATIC SMBIOS_STRUCTURE  SmbiosTable19Data = {SMBIOS_TYPE_MEMORY_ARRAY_MAPPED_ADDRESS, sizeof (SMBIOS_TABLE_TYPE19), SMBIOS_HANDLE_PI_RESERVED};
STATIC SMBIOS_STRUCTURE  SmbiosTable32Data = {SMBIOS_TYPE_SYSTEM_BOOT_INFORMATION, sizeof (SMBIOS_TABLE_TYPE32), SMBIOS_HANDLE_PI_RESERVED};

/** The platform configuration repository information.
*/
STATIC
EDKII_PLATFORM_REPOSITORY_INFO Lx2160aPlatformRepositoryInfo = {
  /// Configuration Manager information
  { CONFIGURATION_MANAGER_REVISION, CFG_MGR_OEM_ID },

  // ACPI Table List
  {
    // FADT Table
    {
      EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
      EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdFadt),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // GTDT Table
    {
      EFI_ACPI_6_2_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE,
      EFI_ACPI_6_2_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdGtdt),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // MADT Table
    {
      EFI_ACPI_6_2_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE,
      EFI_ACPI_6_2_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdMadt),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // PCI MCFG Table
    {
      EFI_ACPI_6_2_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE,
      EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_SPACE_ACCESS_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdMcfg),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // SPCR Table
    {
      EFI_ACPI_6_2_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE,
      EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdSpcr),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // DBG2 Table
    {
      EFI_ACPI_6_2_DEBUG_PORT_2_TABLE_SIGNATURE,
      EFI_ACPI_DBG2_DEBUG_DEVICE_INFORMATION_STRUCT_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdDbg2),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // IORT Table
    {
      EFI_ACPI_6_2_IO_REMAPPING_TABLE_SIGNATURE,
      EFI_ACPI_IO_REMAPPING_TABLE_REVISION,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdIort),
      NULL,
      CFG_MGR_TABLE_ID
    },

    // DSDT Table
    {
      EFI_ACPI_6_2_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE,
      0,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdDsdt),
      (EFI_ACPI_DESCRIPTION_HEADER *) &dsdt_aml_code,
      CFG_MGR_TABLE_ID
    },

    // SSDT Table
    {
      EFI_ACPI_6_2_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE,
      0,
      CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdSsdtFixup),
      NULL,
      CFG_MGR_TABLE_ID
    }

  },

  // SMBIOS table list
  {
    // System Bios
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType00),
      &SmbiosTable0Data
    },
    // System info
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType01),
      &SmbiosTable1Data
    },
    // System Chassis info
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType03),
      &SmbiosTable3Data
    },
    // Processor attributes
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType04),
      &SmbiosTable4Data
    },
    // CPU cache device
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType07),
      &SmbiosTable7Data
    },
    // System slots
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType09),
      &SmbiosTable9Data
    },
    // Memory array
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType16),
      &SmbiosTable16Data
    },
    // Memory devices
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType17),
      &SmbiosTable17Data
    },
    // Memory array mapped address
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType19),
      &SmbiosTable19Data
    },
    // System Boot Info
    {
      CREATE_STD_SMBIOS_TABLE_GEN_ID (EStdSmbiosTableIdType32),
      &SmbiosTable32Data
    }
  },

  // Boot architecture information
  { EFI_ACPI_6_2_ARM_PSCI_COMPLIANT },        // BootArchFlags

  // Power management profile information
  { EFI_ACPI_6_2_PM_PROFILE_MOBILE },         // PowerManagement Profile

  // Generic Timer Info
  {
    // The physical base address for the counter control frame
    TIMER_BASE_ADDRESS,
    // The physical base address for the counter read frame
    TIMER_READ_BASE_ADDRESS,
    // The secure PL1 timer interrupt
    TIMER_SEC_IT,
    // The secure PL1 timer flags
    GTDT_GTIMER_FLAGS,
    // The non-secure PL1 timer interrupt
    TIMER_NON_SEC_IT,
    // The non-secure PL1 timer flags
    GTDT_GTIMER_FLAGS,
    // The virtual timer interrupt
    TIMER_VIRT_IT,
    // The virtual timer flags
    GTDT_GTIMER_FLAGS,
    // The non-secure PL2 timer interrupt
    TIMER_HYP_IT,
    // The non-secure PL2 timer flags
    GTDT_GTIMER_FLAGS
  },

  // Generic Timer Block Information
  {
    {
      // The physical base address for the GT Block Timer structure
      TIMER_GT_BLOCK_0_ADDRESS,
      // The number of timer frames implemented in the GT Block
      PLAT_GTFRAME_COUNT,
      // Reference token for the GT Block timer frame list
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo +
          OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, GTBlock0TimerInfo))
    }
  },

  // GTDT Frames
  {
    {
      0,                                    // UINT8 GTFrameNumber
      TIMER_GT_BASE_0_ADDRESS,              // UINT64 CntBaseX
      TIMER_GT_BASE_0_EL0_ADDRESS,          // UINT64 CntEL0BaseX
      TIMER_FRAME0_IT,                      // UINT32 GTxPhysicalTimerGSIV
      GTDT_FRAME_FLAGS,                     // UINT32 GTxPhysicalTimerFlags
      TIMER_FRAME0_IT,                      // UINT32 GTxVirtualTimerGSIV
      GTDT_FRAME_FLAGS,                     // UINT32 GTxVirtualTimerFlags
      0                                     // UINT32 GTxCommonFlags
    }, //Gtdt.Frames[0]
    {
      1,                                    // UINT8 GTFrameNumber
      TIMER_GT_BASE_1_ADDRESS,              // UINT64 CntBaseX
      GT_BLOCK_FRAME_RES_BASE,              // UINT64 CntEL0BaseX
      TIMER_FRAME1_IT,                      // UINT32 GTxPhysicalTimerGSIV
      GTDT_FRAME_FLAGS,                     // UINT32 GTxPhysicalTimerFlags
      0,                                    // UINT32 GTxVirtualTimerGSIV
      0,                                    // UINT32 GTxVirtualTimerFlags
      GTDT_FRAME_COMMON_FLAGS               // UINT32 GTxCommonFlags
    }, //Gtdt.Frames[1]
    {
      2,                                     // UINT8 GTFrameNumber
      TIMER_GT_BASE_2_ADDRESS,               // UINT64 CntBaseX
      TIMER_GT_BASE_2_EL0_ADDRESS,           // UINT64 CntEL0BaseX
      TIMER_FRAME2_IT,                       // UINT32 GTxPhysicalTimerGSIV
      GTDT_FRAME_FLAGS,                      // UINT32 GTxPhysicalTimerFlags
      0,                                     // UINT32 GTxVirtualTimerGSIV
      0,                                     // UINT32 GTxVirtualTimerFlags
      GTDT_FRAME_COMMON_FLAGS                // UINT32 GTxCommonFlags
    },//Gtdt.Frames[2]
    {
      3,                                     // UINT8 GTFrameNumber
      TIMER_GT_BASE_3_ADDRESS,               // UINT64 CntBaseX
      GT_BLOCK_FRAME_RES_BASE,               // UINT64 CntEL0BaseX
      TIMER_FRAME3_IT,                       // UINT32 GTxPhysicalTimerGSIV
      GTDT_FRAME_FLAGS,                      // UINT32 GTxPhysicalTimerFlags
      0,                                     // UINT32 GTxVirtualTimerGSIV
      0,                                     // UINT32 GTxVirtualTimerFlags
      GTDT_FRAME_COMMON_FLAGS                // UINT32 GTxCommonFlags
    }, //Gtdt.Frames[3]
  }, // End of frames and timer blocks

  // watchdogs
  {
      TIMER_WDT0_CONTROL_BASE,                // UINT64 WatchdogControlFramePhysicalAddress
      TIMER_WDT0_REFRESH_BASE,                // UINT64 RefreshFramePhysicalAddress
      TIMER_WDT0_IT,                          // UINT32 WatchdogTimerGSIV
      SBSA_WATCHDOG_FLAGS                     // UINT32 WatchdogTimerFlags
  },

  /* GIC CPU Interface information
     GIC_ENTRY (CPUInterfaceNumber, Mpidr, PmuIrq, VGicIrq, EnergyEfficiency)
   */
  {
    GICC_ENTRY (0,  GET_MPID (0, 0), 23, 0x19, 0),
    GICC_ENTRY (1,  GET_MPID (0, 1), 23, 0x19, 0),
    GICC_ENTRY (2,  GET_MPID (1, 0), 23, 0x19, 0),
    GICC_ENTRY (3,  GET_MPID (1, 1), 23, 0x19, 0),
    GICC_ENTRY (4,  GET_MPID (2, 0), 23, 0x19, 0),
    GICC_ENTRY (5,  GET_MPID (2, 1), 23, 0x19, 0),
    GICC_ENTRY (6,  GET_MPID (3, 0), 23, 0x19, 0),
    GICC_ENTRY (7,  GET_MPID (3, 1), 23, 0x19, 0),
    GICC_ENTRY (8,  GET_MPID (4, 0), 23, 0x19, 0),
    GICC_ENTRY (9,  GET_MPID (4, 1), 23, 0x19, 0),
    GICC_ENTRY (10, GET_MPID (5, 0), 23, 0x19, 0),
    GICC_ENTRY (11, GET_MPID (5, 1), 23, 0x19, 0),
    GICC_ENTRY (12, GET_MPID (6, 0), 23, 0x19, 0),
    GICC_ENTRY (13, GET_MPID (6, 1), 23, 0x19, 0),
    GICC_ENTRY (14, GET_MPID (7, 0), 23, 0x19, 0),
    GICC_ENTRY (15, GET_MPID (7, 1), 23, 0x19, 0)
  },

  // GIC Distributor Info
  {
    GICD_BASE,                                // UINT64  PhysicalBaseAddress
    0,                                        // UINT32  SystemVectorBase
    GIC_VERSION                               // UINT8   GicVersion
  },

  /* GIC Redistributor */
  {
    GICR_BASE,                                // UINT64 DiscoveryRangeBaseAddress
    GICR_LEN                                  // UINT32 DiscoveryRangeLength
  },

  /* GIC ITS */
  {
    0,                                        // UINT32 GIC ITS ID
    GICI_BASE,                                // UINT64 The 64-bit physical address for ITS
    0                                         // UINT32 Populate the GIC ITS affinity in SRAT table.
  },

  /* MCFG */
  {
    {
      LX2160A_PCI_SEG0_CONFIG_BASE,
      LX2160A_PCI_SEG0,
      LX2160A_PCI_SEG_BUSNUM_MIN,
      LX2160A_PCI_SEG_BUSNUM_MAX,
    },
    {
      LX2160A_PCI_SEG1_CONFIG_BASE,
      LX2160A_PCI_SEG1,
      LX2160A_PCI_SEG_BUSNUM_MIN,
      LX2160A_PCI_SEG_BUSNUM_MAX,
    }
  },

  /* SPCR */
  {
    UART0_BASE,
    UART0_IT,
    115200,
    0,
    EFI_ACPI_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_INTERFACE_TYPE_ARM_PL011_UART
  },

  /* DBG2 */
  {
    UART1_BASE,
    UART1_IT,
    115200,
    175000000,
    EFI_ACPI_DBG2_PORT_SUBTYPE_SERIAL_ARM_SBSA_GENERIC_UART
  },

  // ITS group node
  {
    {
      // Reference token for this Iort node
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsGroupInfo[0])),
      // The number of ITS identifiers in the ITS node.
      1,
      // Reference token for the ITS identifier array
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsIdentifierArray[0])),
    }
  },

  // ITS identifier array
  {
    {
      // The ITS Identifier
      0
    }
  },

  // Named Components in IORT table
  {
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[0])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[0])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.MCE0" // refer MC.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[1])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[1])),
      0,
      0,
      0,
      0,
      40,
      "\\_SB_.USB0" // refer USB.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[2])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[2])),
      0,
      0,
      0,
      0,
      40,
      "\\_SB_.USB1" // refer USB.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[3])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[3])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SDC0", // refer Esdhc.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[4])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[4])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SDC0", // refer Esdhc.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[5])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[5])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SAT0", // refer Sata.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[6])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[6])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SAT1", // refer Sata.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[7])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[7])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SAT2", // refer Sata.asl
    },
    {
      // Reference token for this named component
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, NamedComponentInfo[8])),
      1,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[8])),
      0,
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      48,
      "\\_SB_.SAT3", // refer Sata.asl
    }
  },

  // ID Mappings
  {
    {
      NXP_MC_LX2160A_STREAM_ID,
      0,
      NXP_MC_LX2160A_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      0
    },
    {
      NXP_USB0_STREAM_ID,
      0,
      NXP_USB0_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_USB1_STREAM_ID,
      0,
      NXP_USB1_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SDMMC0_STREAM_ID,
      0,
      NXP_SDMMC0_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SDMMC1_STREAM_ID,
      0,
      NXP_SDMMC1_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SATA0_STREAM_ID,
      0,
      NXP_SATA0_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SATA1_STREAM_ID,
      0,
      NXP_SATA1_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SATA2_STREAM_ID,
      0,
      NXP_SATA2_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      NXP_SATA3_STREAM_ID,
      0,
      NXP_SATA3_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      EFI_ACPI_IORT_ID_MAPPING_FLAGS_SINGLE
    },
    {
      0,
      0,
      0x1800,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      0
    },
    {
      0,
      0,
      0x2800,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      0
    },
    {
      NXP_MC_LX2160A_STREAM_ID,
      0,
      NXP_MC_LX2160A_STREAM_ID,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsIdentifierArray[0])),
      0
    },
    {
      NXP_DPAA2_STREAM_ID_START,
      NXP_DPAA2_STREAM_ID_COUNT - 1,
      NXP_DPAA2_STREAM_ID_START,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsIdentifierArray[0])),
      0
    },
    {
      0x1800,
      0,
      0x1800,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsIdentifierArray[0])),
      0
    },
    {
      0x2800,
      0,
      0x2800,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, ItsIdentifierArray[0])),
      0
    }
  },

  // Root Complex node info
  {
    // node 1 info
    {
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, RootComplexInfo[0])),
      0,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[9])),
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      EFI_ACPI_IORT_ROOT_COMPLEX_ATS_UNSUPPORTED,
      LX2160A_PCI_SEG0,  // refer to Pci.asl
    },
    // node 2 info
    {
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, RootComplexInfo[1])),
      0,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[10])),
      EFI_ACPI_IORT_MEM_ACCESS_PROP_CCA,
      0,
      EFI_ACPI_IORT_MEM_ACCESS_FLAGS_CPM | EFI_ACPI_IORT_MEM_ACCESS_FLAGS_DACS,
      EFI_ACPI_IORT_ROOT_COMPLEX_ATS_UNSUPPORTED,
      LX2160A_PCI_SEG1,  // refer to Pci.asl
    }
  },

  // SMMU V1/V2 nodes
  {
    {
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, SmmuV1SmmuV2Info[0])),
      4,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, IdMappingArray[11])),
      0x5000000,
      0x800000,
      EFI_ACPI_IORT_SMMUv1v2_MODEL_MMU500,
      EFI_ACPI_IORT_SMMUv1v2_FLAG_DVM | EFI_ACPI_IORT_SMMUv1v2_FLAG_COH_WALK,
      64, // Actual for lx2 64 interupts available
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, InterruptContextArray[0])),
      10,
      (CM_OBJECT_TOKEN)((UINT8*)&Lx2160aPlatformRepositoryInfo + OFFSET_OF (EDKII_PLATFORM_REPOSITORY_INFO, PmuInterruptArray[0])),
      47,
      EFI_ACPI_IORT_SMMUv1v2_INT_FLAG_LEVEL,
      48,
      EFI_ACPI_IORT_SMMUv1v2_INT_FLAG_LEVEL
    }
  },

  // SMMU Interupt Context
  SMMU_INTERRUPT_CONTEXT_ARRAY

  // PMU Interupt Context
  PMU_INTERRUPT_CONTEXT_ARRAY

  // SMBIOS system bios info
  {
    1,     /* SMBIOS_TABLE_STRING       Vendor */
    2,     /* SMBIOS_TABLE_STRING       BiosVersion */
    0xE800,/* UINT16                    BiosSegment */
    3,     /* SMBIOS_TABLE_STRING       BiosReleaseDate */
    0,     /* UINT8                     BiosSize */
    {
      0,0,0,0,0,0,
      1, /* PCI supported */
      0,
      0, /* PNP supported */
      0,
      1, /* BIOS upgradable */
      0, 0, 0,
      0, /* Boot from CD not supported */
      1, /* selectable boot */
    },   /* MISC_BIOS_CHARACTERISTICS BiosCharacteristics */
    {    /* BIOSCharacteristicsExtensionBytes[2] */
      0x3,
      0xC,
    },
    0,     /* UINT8 SystemBiosMajorRelease */
    0,     /* UINT8 SystemBiosMinorRelease */
    0xFF,  /* UINT8 EmbeddedControllerFirmwareMajorRelease */
    0xFF,  /* UINT8 EmbeddedControllerFirmwareMinorRelease */
  },

  // SMBIOS System Info
  {
    1,     /* Manufacturer */
    2,     /* Product Name */
    3,     /* Version */
    4,     /* Serial */
    { 0x8a95d198, 0x7f46, 0x11e5, { 0xbf,0x8b,0x08,0x00,0x27,0x04,0xd4,0x8e }},    /* UUID */
    6,     /* Wakeup type */
    0,     /* SKU */
    0,     /* Family */
  },

  // SMBIOS system Enclosure/Chassis info
  {
    1,   /* Manufacturer */
    9,   /* enclosure type (laptop) */
    2,   /* version */
    3,   /* serial */
    0,   /* asset tag */
    ChassisStateUnknown,   /* boot chassis state */
    ChassisStateSafe,      /* power supply state */
    ChassisStateSafe,      /* thermal state */
    ChassisSecurityStatusNone,   /* security state */
    {0,0,0,0,}, /* OEM defined */
    1,          /* 1U height */
    1,          /* number of power cords */
    0,          /* no contained elements */
  },

  // SMBIOS Processor Attributes
  {
    1,                                       /* socket type */
    3,                                       /* processor type CPU */
    ProcessorFamilyIndicatorFamily2,         /* processor family, acquire from field2 */
    2,                                       /* manufactuer */
    {{0,},{0.}},                             /* processor id */
    5,                                       /* version */
    {0,0,0,0,0,1},                           /* voltage */
    100,                                     /* external clock */
    2200,                                    /* max speed */
    2000,                                    /* current speed */
    0x41,                                    /* status */
    ProcessorUpgradeOther,
    SMBIOS_HANDLE_A57_L1I,                   /* l1 cache handle */
    SMBIOS_HANDLE_A57_L2,                    /* l2 cache handle */
    0xFFFF,                                  /* l3 cache handle */
    0,                                       /* serial not set */
    0,                                       /* asset not set */
    8,                                       /* part number */
    16,                                      /* core count in socket */
    16,                                      /* enabled core count in socket */
    0,                                       /* threads per socket */
    0xEC,                                    /* processor characteristics */
    ProcessorFamilyARM,                      /* ARM core */
  },

  /// SMBIOS CPU cache device in the system
  {
    1,
    0x280,                                 /* L1 enabled,varies with Memory Address */
    0x0030,                                /* 48k i cache max */
    0x0030,                                /* 48k installed */
    {0,1},                                 /* SRAM type */
    {0,1},                                 /* SRAM type */
    0,                                     /* unkown speed */
    CacheErrorParity,                      /* parity checking */
    CacheTypeInstruction,                  /* instruction cache */
    CacheAssociativityOther,               /* three way */
    0x400,                                 /* 1 MB max L2 cache */
    0x400,                                 /* 1 MB installed L2 Cache */
  },

  // SMBIOS System slots
  {
    {
      1,
      SlotTypePciExpressGen3X4,
      SlotDataBusWidth4X,
      SlotUsageAvailable,
      SlotLengthShort,
      0,                 // SlotId
      {1},               // unknown
      {1,0,0},           // PME and SMBUS
      0x0,               // Segment
      0x0,               // Bus
      0x0                // DevFunc
    },
    {
      2,
      SlotTypePciExpressGen3X8,
      SlotDataBusWidth8X,
      SlotUsageAvailable,
      SlotLengthShort,
      0,                // SlotId
      {1},              // unknown
      {1,0,0},          // PME and SMBUS
      0x1,              // Segment
      0x0,              // Bus
      0x0               // DevFunc
    }
  },

  // SMBIOS Memory Array for Type16 Table
  {
    MemoryArrayLocationSystemBoard,             // MemoryArrayLocation
    MemoryArrayUseSystemMemory,                 // MemoryArrayUse
    MemoryErrorCorrectionSingleBitEcc,          // MemoryErrorCorrection
    0x800000,                                   // 8GB
    0xFFFE,                                     // No error information structure
    0x1,                                        // soldered memory
  },

  // SMBIOS Memory devices
  {
    SMBIOS_HANDLE_MEMORY, /* array to which this module belongs */
    0xFFFE,               /* no errors */
    72, /* single DIMM, no ECC is 64bits (for ecc this would be 72) */
    64, /* data width of this device (64-bits) */
    0x7FFF, /* for size 32GB -1MB or greater*/
    0x09,   /* DIMM */
    0,      /* not part of a set */
    1,      /* right side of board */
    2,      /* bank 0 */
    MemoryTypeDdr4,                  /* LP DDR4 */
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}, /* unbuffered */
    2900,                            /* 2900Mhz DDR */
    0, /* varies between diffrent production runs */
    0, /* serial */
    0, /* asset tag */
    0  /* part number */
  },

  // Memory array mapped address
  {
    0xFFFFFFFF,         /* invalid, look at extended addr field */
    0xFFFFFFFF,
    SMBIOS_HANDLE_DIMM, /* handle */
    1,
    0x000000000,        /* starting addr of first 32GB */
    0x7FFFFFFFE,        /* ending addr of first 32GB */
  },

  // SMBIOS Boot Info for Type32 Table
  {
    BootInformationStatusNoError,               // System Boot ststus
  },

  // SSDT fixup info
  {
    0x00,
    0x00,
    0x00,
    AQR_PHY4_IT
  },

  2.0                                         // LX2 board revision
};

/** Return ITS Group Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_ITS_GROUP_NODE object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetItsGroupInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->ItsGroupInfo) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->ItsGroupInfo);
  CmObject->Data = (VOID*)&PlatformRepo->ItsGroupInfo;
  CmObject->Count = sizeof (PlatformRepo->ItsGroupInfo) /
                      sizeof (PlatformRepo->ItsGroupInfo[0]);
  return EFI_SUCCESS;
}

/** Return Named Component Node Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_NAMED_COMPONENT_NODE object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetNamedComponentInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->NamedComponentInfo) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->NamedComponentInfo);
  CmObject->Data = (VOID*)&PlatformRepo->NamedComponentInfo;
  CmObject->Count = sizeof (PlatformRepo->NamedComponentInfo) /
                      sizeof (PlatformRepo->NamedComponentInfo[0]);
  return EFI_SUCCESS;
}

/** Return GIC Identifier Array Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_ITS_IDENTIFIER object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetItsIdentifierArray (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->ItsIdentifierArray) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->ItsIdentifierArray);
  CmObject->Data = (VOID*)&PlatformRepo->ItsIdentifierArray;
  CmObject->Count = sizeof (PlatformRepo->ItsIdentifierArray) /
                      sizeof (PlatformRepo->ItsIdentifierArray[0]);
  return EFI_SUCCESS;
}

/** Return Root Complex Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_ROOT_COMPLEX_NODE object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetRootComplexInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->RootComplexInfo) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->RootComplexInfo);
  CmObject->Data = (VOID*)&PlatformRepo->RootComplexInfo;
  CmObject->Count = sizeof (PlatformRepo->RootComplexInfo) /
                      sizeof (PlatformRepo->RootComplexInfo[0]);
  return EFI_SUCCESS;
}

/** Return Device ID Mapping Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_ID_MAPPING object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetIdMappingArrayInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;
  UINT32                            TotalObjCount;
  UINT32                            ObjIndex;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  TotalObjCount = ARRAY_SIZE (PlatformRepo->IdMappingArray);

  for (ObjIndex = 0; ObjIndex < TotalObjCount; ObjIndex++) {
    if (Token == (CM_OBJECT_TOKEN)&PlatformRepo->IdMappingArray[ObjIndex])
    {
      CmObject->ObjectId = CmObjectId;
      CmObject->Size = sizeof (PlatformRepo->IdMappingArray);
      CmObject->Data = (VOID*)&PlatformRepo->IdMappingArray;
      CmObject->Count = TotalObjCount;
      return EFI_SUCCESS;
    }
  }

  return EFI_NOT_FOUND;
}

/** Return Device ID Mapping Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_SMMUV1_SMMUV2_NODE object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetSmmuV1SmmuV2Info (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->SmmuV1SmmuV2Info) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->SmmuV1SmmuV2Info);
  CmObject->Data = (VOID*)&PlatformRepo->SmmuV1SmmuV2Info;
  CmObject->Count = sizeof (PlatformRepo->SmmuV1SmmuV2Info) /
                      sizeof (PlatformRepo->SmmuV1SmmuV2Info[0]);
  return EFI_SUCCESS;
}

/** Return SMMU Interrupt Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      SearchToken    A unique token for identifying the requested
  CM_ARM_SMMU_INTERRUPT object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetInterruptContextArrayInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token == (CM_OBJECT_TOKEN)&PlatformRepo->InterruptContextArray) {
    CmObject->ObjectId = CmObjectId;
    CmObject->Size = sizeof (PlatformRepo->InterruptContextArray);
    CmObject->Data = (VOID*)&PlatformRepo->InterruptContextArray;
    CmObject->Count = sizeof (PlatformRepo->InterruptContextArray) /
      sizeof (PlatformRepo->InterruptContextArray[0]);
  } else if (Token == (CM_OBJECT_TOKEN)&PlatformRepo->PmuInterruptArray) {
    CmObject->ObjectId = CmObjectId;
    CmObject->Size = sizeof (PlatformRepo->PmuInterruptArray);
    CmObject->Data = (VOID*)&PlatformRepo->PmuInterruptArray;
    CmObject->Count = sizeof (PlatformRepo->PmuInterruptArray) /
      sizeof (PlatformRepo->PmuInterruptArray[0]);
  } else {
    return EFI_NOT_FOUND;
  }
  return EFI_SUCCESS;
}

/** Initialize the platform configuration repository.

  @param [in]  This        Pointer to the Configuration Manager Protocol.

  @retval EFI_SUCCESS   Success
**/
STATIC
EFI_STATUS
EFIAPI
InitializePlatformRepository (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This
  )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  PlatformRepo = This->PlatRepoInfo;

  DEBUG ((DEBUG_INFO, "Lx2 Rev = 0x%x\n", PlatformRepo->Lx2160aRevision));
  return EFI_SUCCESS;
}

/** Return PCI Configuration Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      Token          A unique token for identifying the requested
  CM_ARM_PCI_INFO object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetPciConfigInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;
  UINT32                            TotalObjCount;
  UINT32                            ObjIndex;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  TotalObjCount = ARRAY_SIZE (PlatformRepo->PciConfigInfo);

  for (ObjIndex = 0; ObjIndex < TotalObjCount; ObjIndex++) {
    if (Token == (CM_OBJECT_TOKEN)&PlatformRepo->PciConfigInfo[ObjIndex])
    {
      CmObject->ObjectId = CmObjectId;
      CmObject->Size = sizeof (PlatformRepo->PciConfigInfo[ObjIndex]);
      CmObject->Data = (VOID*)&PlatformRepo->PciConfigInfo[ObjIndex];
      CmObject->Count = 1;
      return EFI_SUCCESS;
    }
  }

  return EFI_NOT_FOUND;
}

/** Return GIC CPU Interface Info.
  @param [in]      This           Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId     The Object ID of the CM object requested
  @param [in]      Token          A unique token for identifying the requested
  CM_ARM_GICC_INFO object.
  @param [in, out] CmObject       Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS             Success.
  @retval EFI_INVALID_PARAMETER   A parameter is invalid.
  @retval EFI_NOT_FOUND           The required object information is
  not found.
 **/
EFI_STATUS
EFIAPI
GetGicCInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->GicCInfo) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->GicCInfo);
  CmObject->Data = (VOID*)&PlatformRepo->GicCInfo;
  CmObject->Count = sizeof (PlatformRepo->GicCInfo) /
                      sizeof (PlatformRepo->GicCInfo[0]);
  return EFI_SUCCESS;
}

/** Return a GT Block timer frame info list.
  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       A token for identifying the object
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
  descriptor describing the requested Object.
  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
 **/
EFI_STATUS
  EFIAPI
GetGTBlockTimerFrameInfo (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  if (Token != (CM_OBJECT_TOKEN)&PlatformRepo->GTBlock0TimerInfo) {
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->GTBlock0TimerInfo);
  CmObject->Data = (VOID*)&PlatformRepo->GTBlock0TimerInfo;
  CmObject->Count = sizeof (PlatformRepo->GTBlock0TimerInfo) /
                      sizeof (PlatformRepo->GTBlock0TimerInfo[0]);
  return EFI_SUCCESS;
}

/** Return a smbios Type9 Table Info.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the requested Object.

  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
**/
EFI_STATUS
EFIAPI
GetSmbiosType9Info (
    IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
    IN  CONST CM_OBJECT_ID                                  CmObjectId,
    IN  CONST CM_OBJECT_TOKEN                               Token,
    IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
    )
{
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;
  UINT32                            ObjCnt;
  UINT32                            RefCnt;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  PlatformRepo = This->PlatRepoInfo;

  ObjCnt  = sizeof (PlatformRepo->Type9SystemSlotInfo) /
                      sizeof (PlatformRepo->Type9SystemSlotInfo[0]);
  RefCnt  = (Token - 1);

  if (RefCnt > ObjCnt) {
    DEBUG ((
          DEBUG_ERROR,
          "GetSmbiosType9Info: No Info found. Size = %d, Index = %d\n",
          ObjCnt,
          RefCnt
          ));
    return EFI_NOT_FOUND;
  }

  CmObject->ObjectId = CmObjectId;
  CmObject->Size = sizeof (PlatformRepo->Type9SystemSlotInfo[RefCnt]);
  CmObject->Data = (VOID*)&PlatformRepo->Type9SystemSlotInfo[RefCnt];
  CmObject->Count = 1;

  return EFI_SUCCESS;
}

/** Return a standard namespace object.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the requested Object.

  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
**/
EFI_STATUS
EFIAPI
GetStandardNameSpaceObject (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
  IN  CONST CM_OBJECT_ID                                  CmObjectId,
  IN  CONST CM_OBJECT_TOKEN                               Token OPTIONAL,
  IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
  )
{
  EFI_STATUS                        Status;
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;
  UINT32                            TableCount;

  Status = EFI_SUCCESS;
  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }
  PlatformRepo = This->PlatRepoInfo;

  switch (GET_CM_OBJECT_ID (CmObjectId)) {
    HANDLE_CM_OBJECT (
      EStdObjCfgMgrInfo,
      CmObjectId,
      PlatformRepo->CmInfo,
      1
      );

    case EStdObjAcpiTableList:
      CmObject->ObjectId = CmObjectId;
      TableCount = sizeof (PlatformRepo->CmAcpiTableList) /
                     sizeof (PlatformRepo->CmAcpiTableList[0]);
      CmObject->Data = (VOID*)&PlatformRepo->CmAcpiTableList;
      CmObject->Size = sizeof (PlatformRepo->CmAcpiTableList);
      CmObject->Count = TableCount;
      DEBUG ((
        DEBUG_INFO,
        "EStdObjAcpiTableList: Ptr = 0x%p. Size = %d, Count = %d\n",
        CmObject->Data,
        CmObject->Size,
        CmObject->Count
        ));
      break;

    case EStdObjSmbiosTableList:
      CmObject->ObjectId = CmObjectId;
      TableCount = sizeof (PlatformRepo->CmSmbiosTableList) /
                     sizeof (PlatformRepo->CmSmbiosTableList[0]);
      CmObject->Data = (VOID*)&PlatformRepo->CmSmbiosTableList;
      CmObject->Size = sizeof (PlatformRepo->CmSmbiosTableList);
      CmObject->Count = TableCount;
      DEBUG ((
        DEBUG_INFO,
        "EStdObjSmbiosTableList: Ptr = 0x%p. Size = %d, Count = %d\n",
        CmObject->Data,
        CmObject->Size,
        CmObject->Count
        ));
      break;

    default: {
      Status = EFI_NOT_FOUND;
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: Object 0x%x. Status = %r\n",
        CmObjectId,
        Status
        ));
      break;
    }
  }

  return Status;
}

/** Return an ARM namespace object.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the requested Object.

  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
**/
EFI_STATUS
EFIAPI
GetArmNameSpaceObject (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
  IN  CONST CM_OBJECT_ID                                  CmObjectId,
  IN  CONST CM_OBJECT_TOKEN                               Token OPTIONAL,
  IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
  )
{
  EFI_STATUS                        Status;
  EDKII_PLATFORM_REPOSITORY_INFO  * PlatformRepo;

  Status = EFI_SUCCESS;
  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }
  PlatformRepo = This->PlatRepoInfo;

  switch (GET_CM_OBJECT_ID (CmObjectId)) {
    HANDLE_CM_OBJECT (
      EArmObjBootArchInfo,
      CmObjectId,
      PlatformRepo->BootArchInfo,
      1
      );
    HANDLE_CM_OBJECT (
      EArmObjPowerManagementProfileInfo,
      CmObjectId,
      PlatformRepo->PmProfileInfo,
      1
      );
    HANDLE_CM_OBJECT (
        EArmObjGenericTimerInfo,
        CmObjectId,
        PlatformRepo->GenericTimerInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjPlatformGenericWatchdogInfo,
        CmObjectId,
        PlatformRepo->Watchdog,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjPlatformGTBlockInfo,
        CmObjectId,
        PlatformRepo->GTBlockInfo,
        (sizeof (PlatformRepo->GTBlockInfo) /
         sizeof (PlatformRepo->GTBlockInfo[0]))
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjGTBlockTimerFrameInfo,
        CmObjectId,
        PlatformRepo->GTBlock0TimerInfo,
        (sizeof (PlatformRepo->GTBlock0TimerInfo) /
         sizeof (PlatformRepo->GTBlock0TimerInfo[0])),
        Token,
        GetGTBlockTimerFrameInfo
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjGicCInfo,
        CmObjectId,
        PlatformRepo->GicCInfo,
        ARRAY_SIZE (PlatformRepo->GicCInfo),
        Token,
        GetGicCInfo
        );
    HANDLE_CM_OBJECT (
        EArmObjGicDInfo,
        CmObjectId,
        PlatformRepo->GicDInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjGicRedistributorInfo,
        CmObjectId,
        PlatformRepo->GicRedistInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjGicItsInfo,
        CmObjectId,
        PlatformRepo->GicItsInfo,
        1
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjPciConfigSpaceInfo,
        CmObjectId,
        PlatformRepo->PciConfigInfo,
        (sizeof (PlatformRepo->PciConfigInfo) /
         sizeof (PlatformRepo->PciConfigInfo[0])),
        Token,
        GetPciConfigInfo
        );
    HANDLE_CM_OBJECT (
        EArmObjSerialConsolePortInfo,
        CmObjectId,
        PlatformRepo->SpcrSerialPort,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjSerialDebugPortInfo,
        CmObjectId,
        PlatformRepo->DbgSerialPort,
        1
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjItsGroup,
        CmObjectId,
        PlatformRepo->ItsGroupInfo,
        (sizeof (PlatformRepo->ItsGroupInfo) /
         sizeof (PlatformRepo->ItsGroupInfo[0])),
        Token,
        GetItsGroupInfo
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjNamedComponent,
        CmObjectId,
        PlatformRepo->NamedComponentInfo,
        (sizeof (PlatformRepo->NamedComponentInfo) /
         sizeof (PlatformRepo->NamedComponentInfo[0])),
        Token,
        GetNamedComponentInfo
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjGicItsIdentifierArray,
        CmObjectId,
        PlatformRepo->ItsIdentifierArray,
        (sizeof (PlatformRepo->ItsIdentifierArray) /
         sizeof (PlatformRepo->ItsIdentifierArray[0])),
        Token,
        GetItsIdentifierArray
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjRootComplex,
        CmObjectId,
        PlatformRepo->RootComplexInfo,
        (sizeof (PlatformRepo->RootComplexInfo) /
         sizeof (PlatformRepo->RootComplexInfo[0])),
        Token,
        GetRootComplexInfo
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjIdMappingArray,
        CmObjectId,
        PlatformRepo->IdMappingArray,
        (sizeof (PlatformRepo->IdMappingArray) /
         sizeof (PlatformRepo->IdMappingArray[0])),
        Token,
        GetIdMappingArrayInfo
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjSmmuV1SmmuV2,
        CmObjectId,
        PlatformRepo->SmmuV1SmmuV2Info,
        (sizeof (PlatformRepo->SmmuV1SmmuV2Info) /
         sizeof (PlatformRepo->SmmuV1SmmuV2Info[0])),
        Token,
        GetSmmuV1SmmuV2Info
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjSmmuInterruptArray,
        CmObjectId,
        PlatformRepo->InterruptContextArray,
        (sizeof (PlatformRepo->InterruptContextArray) /
         sizeof (PlatformRepo->InterruptContextArray[0])),
        Token,
        GetInterruptContextArrayInfo
        );
    HANDLE_CM_OBJECT (
        EArmObjSystemBiosInfoType0,
        CmObjectId,
        PlatformRepo->Type0SystemBiosInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjSystemInfoType1,
        CmObjectId,
        PlatformRepo->Type1SystemInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjSystemChassisInfoType3,
        CmObjectId,
        PlatformRepo->Type3SystemChassisInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjProcessorAttrInfoType4,
        CmObjectId,
        PlatformRepo->Type4ProcessorAttrInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjCpuCacheDeviceInfoType7,
        CmObjectId,
        PlatformRepo->Type7CpuCacheDeviceInfo,
        1
        );
    HANDLE_CM_OBJECT_REF_BY_TOKEN (
        EArmObjSystemSlotType9,
        CmObjectId,
        PlatformRepo->Type9SystemSlotInfo,
        (sizeof (PlatformRepo->Type9SystemSlotInfo) /
         sizeof (PlatformRepo->Type9SystemSlotInfo[0])),
         Token,
         GetSmbiosType9Info
        );
    HANDLE_CM_OBJECT (
        EArmObjMemorryArrayType16,
        CmObjectId,
        PlatformRepo->Type16MemoryArray,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjMemoryDeviceType17,
        CmObjectId,
        PlatformRepo->Type17MemoryDeviceInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjMemoryMappedAddressType19,
        CmObjectId,
        PlatformRepo->Type19MemoryMappedAddressInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjSystemBootType32,
        CmObjectId,
        PlatformRepo->Type32SystemBootInfo,
        1
        );
    HANDLE_CM_OBJECT (
        EArmObjSsdtFixupInfo,
        CmObjectId,
        PlatformRepo->SsdtFixupInfo,
        1
        );

    default: {
      Status = EFI_NOT_FOUND;
      DEBUG ((
        DEBUG_INFO,
        "INFO: Object 0x%x. Status = %r\n",
        CmObjectId,
        Status
        ));
      break;
    }
  }//switch

  return Status;
}

/** Return an OEM namespace object.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the requested Object.

  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
**/
EFI_STATUS
EFIAPI
GetOemNameSpaceObject (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
  IN  CONST CM_OBJECT_ID                                  CmObjectId,
  IN  CONST CM_OBJECT_TOKEN                               Token OPTIONAL,
  IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
  )
{
  EFI_STATUS  Status;

  Status = EFI_SUCCESS;
  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  switch (GET_CM_OBJECT_ID (CmObjectId)) {
    default: {
      Status = EFI_NOT_FOUND;
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: Object 0x%x. Status = %r\n",
        CmObjectId,
        Status
        ));
      break;
    }
  }

  return Status;
}

/** The GetObject function defines the interface implemented by the
    Configuration Manager Protocol for returning the Configuration
    Manager Objects.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in, out] CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the requested Object.

  @retval EFI_SUCCESS           Success.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The required object information is not found.
**/
EFI_STATUS
EFIAPI
Lx2160aPlatformGetObject (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
  IN  CONST CM_OBJECT_ID                                  CmObjectId,
  IN  CONST CM_OBJECT_TOKEN                               Token OPTIONAL,
  IN  OUT   CM_OBJ_DESCRIPTOR                     * CONST CmObject
  )
{
  EFI_STATUS  Status;

  if ((This == NULL) || (CmObject == NULL)) {
    ASSERT (This != NULL);
    ASSERT (CmObject != NULL);
    return EFI_INVALID_PARAMETER;
  }

  switch (GET_CM_NAMESPACE_ID (CmObjectId)) {
    case EObjNameSpaceStandard:
      Status = GetStandardNameSpaceObject (This, CmObjectId, Token, CmObject);
      break;
    case EObjNameSpaceArm:
      Status = GetArmNameSpaceObject (This, CmObjectId, Token, CmObject);
      break;
    case EObjNameSpaceOem:
      Status = GetOemNameSpaceObject (This, CmObjectId, Token, CmObject);
      break;
    default: {
      Status = EFI_INVALID_PARAMETER;
      DEBUG ((
        DEBUG_ERROR,
        "ERROR: Unknown Namespace Object = 0x%x. Status = %r\n",
        CmObjectId,
        Status
        ));
      break;
    }
  }

  return Status;
}

/** The SetObject function defines the interface implemented by the
    Configuration Manager Protocol for updating the Configuration
    Manager Objects.

  @param [in]      This        Pointer to the Configuration Manager Protocol.
  @param [in]      CmObjectId  The Configuration Manager Object ID.
  @param [in]      Token       An optional token identifying the object. If
                               unused this must be CM_NULL_TOKEN.
  @param [in]      CmObject    Pointer to the Configuration Manager Object
                               descriptor describing the Object.

  @retval EFI_UNSUPPORTED  This operation is not supported.
**/
EFI_STATUS
EFIAPI
Lx2160aPlatformSetObject (
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST This,
  IN  CONST CM_OBJECT_ID                                  CmObjectId,
  IN  CONST CM_OBJECT_TOKEN                               Token OPTIONAL,
  IN        CM_OBJ_DESCRIPTOR                     * CONST CmObject
  )
{
  return EFI_UNSUPPORTED;
}

/** A structure describing the configuration manager protocol interface.
*/
STATIC
CONST
EDKII_CONFIGURATION_MANAGER_PROTOCOL Lx2160aConfigManagerProtocol = {
  CREATE_REVISION (1, 0),
  Lx2160aPlatformGetObject,
  Lx2160aPlatformSetObject,
  &Lx2160aPlatformRepositoryInfo
};

/**
  Entrypoint of Configuration Manager Dxe.

  @param  ImageHandle
  @param  SystemTable

  @return EFI_SUCCESS
  @return EFI_LOAD_ERROR
  @return EFI_OUT_OF_RESOURCES

**/
EFI_STATUS
EFIAPI
ConfigurationManagerDxeInitialize (
  IN EFI_HANDLE          ImageHandle,
  IN EFI_SYSTEM_TABLE  * SystemTable
  )
{
  EFI_STATUS  Status;

  Status = gBS->InstallProtocolInterface (
                  &ImageHandle,
                  &gEdkiiConfigurationManagerProtocolGuid,
                  EFI_NATIVE_INTERFACE,
                  (VOID*)&Lx2160aConfigManagerProtocol
                  );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: Failed to get Install Configuration Manager Protocol." \
      " Status = %r\n",
      Status
      ));
    goto error_handler;
  }

  Status = InitializePlatformRepository (
    &Lx2160aConfigManagerProtocol
    );
  if (EFI_ERROR (Status)) {
    DEBUG ((
      DEBUG_ERROR,
      "ERROR: Failed to initialize the Platform Configuration Repository." \
      " Status = %r\n",
      Status
      ));
  }

error_handler:
  return Status;
}
